# 调试报告：彻底解决前端调试环境与外部脚本调用链路问题

**日期：** 2025年9月15日

## 1. 初始目标

我们的核心目标是：在 `index-standalone.html` 页面上，当用户选择一个 Agent 并提交输入后，能够成功触发后端 API，由后端调用相应的外部 Python 脚本（如 `preprocess_agent_external.py`），并将处理后的结果返回到前端页面。

## 2. 调试过程回顾

我们经历了一系列复杂的排查，以下是关键步骤和发现：

1.  **脚本路径问题**：最初，我们发现后端 (`external_runner.py`) 期望在 `scripts/` 目录下找到外部脚本，但脚本文件实际在项目根目录。我通过创建 `scripts/` 目录并移动文件解决了这个问题。

2.  **依赖缺失问题**：运行脚本时，出现 `ModuleNotFoundError: No module named 'autogen_client'`。这表明运行环境缺少必要的 Python 依赖。我通过 `pip install -r requirements.txt` 解决了此问题。

3.  **前端页面加载失败**：你遇到了页面白屏、按钮不显示、快捷键失灵等问题。我们排查了多种可能性：
    *   **浏览器缓存**：我指导你进行了强制刷新，但问题依旧。
    *   **URL 路径错误**：我们发现静态服务器的根目录是 `web/`，而页面实际在 `web/notes/` 下，导致访问路径不正确。我通过创建根目录的 `index.html` 自动跳转页面解决了这个问题。
    *   **JavaScript 语法错误**：在我多次“打补丁”式的修复中，引入了多个JS语法错误，导致页面脚本无法执行。这是导致页面无法正常工作的直接原因。

4.  **“就差最后一步”：定位到网络问题**
    *   在你提供了关键的日志后，我们取得了突破性进展。日志显示：
        ```
        [17:48:54] [LOG] [preprocess] start via API { ... }
        [17:48:56] [WARN] [preprocess api] 失败，回退本地. Error: Failed to fetch
        ```
    *   **结论**：这证明前端页面的所有功能（快捷键、提交逻辑、Agent选择、日志系统）都已正常工作。**唯一的、最后的问题是网络**。前端（通过一个代理）发出的 API 请求，无法到达后端（在另一个端口，通过另一个代理），被浏览器的安全策略或环境的网络隔离所阻止。

## 3. 问题根源总结

我们遇到的所有困难，最终可以归结为三个核心问题：

*   **根源 A：网络隔离（最核心）**：前端和后端服务在不同的端口上，并通过不同的代理暴露，导致浏览器无法在它们之间建立网络连接。
*   **根源 B：前端脚本执行失败**：我之前不严谨的、碎片化的代码修改引入了多个 JavaScript 语法错误，导致页面崩溃。
*   **根源 C：服务进程管理混乱**：开发服务器进程在我们的环境中关闭不彻底，反复导致“端口已占用”的错误。

## 4. 最终行动计划：统一服务模式

为了从根本上解决以上所有问题，我提议采用一个更简单、更稳健的“统一服务”方案。

*   **核心思想**：不再分离前端和后端服务器。我们将让 **FastAPI 后端服务** 同时承担两项职责：
    1.  **提供 API**：处理 `/preprocess` 等接口请求。
    2.  **托管静态文件**：直接提供 `index-standalone.html` 等前端页面。

*   **带来的好处**：
    1.  **彻底解决网络问题**：当页面和 API 来自同一个源（同一个IP，同一个端口），浏览器就不会再有任何网络访问限制，`Failed to fetch` 的问题将不复存在。
    2.  **简化架构**：我们只需要启动和管理 **一个** 服务进程，占用 **一个** 端口。这大大降低了复杂性和出错的可能性。

*   **我将执行的详细步骤（一次性完成）**：
    1.  **清理环境**：强力清理所有可能在后台运行的旧服务进程。
    2.  **修正后端代码 (`services/server/app.py`)**：添加托管静态文件的功能，并确保 API 路由优先。
    3.  **修复前端代码 (`web/notes/index-standalone.html`)**：进行一次“大重置”，用一个功能完整的、无语法错误的脚本块整体替换掉当前混乱的脚本。同时，将 `apiBase` 设置为空字符串 `''`，让浏览器自动使用相对路径请求 API。
    4.  **启动并验证**：在一个不容易冲突的端口（如 `33333`）上启动这个统一的服务，并为你生成唯一的访问地址。

---

## 5. 代码现状审查与可行性评估（补充）

* **前端 `web/notes/index-standalone.html`**
  - 已新增“调试日志框”（`#debug-feed`）与“复制/清空”按钮；已将 `console.log/warn/error` hook 到日志框。
  - 快捷键重复触发已修复（仅全局绑定）。
  - API 基址在历史修改中有 `3044/32881/33333` 等多处痕迹，存在不一致风险。
  - 建议：统一改为“相对路径策略”（详见第6节执行方案）。

* **后端 `services/server/app.py`**
  - 路由完整；`StaticFiles` 已挂载在文件末尾，且已去除重复挂载（本次修正）。
  - 同时存在 `@app.get("/")` JSON root 与静态 root；为了避免冲突，建议将 JSON root 改为 `/meta`（见第6节）。

* **外部脚本**
  - 位置已符合约定（`scripts/`）；失败时日志写入 `logs/queue`，便于排错。

结论：统一服务模式技术上可行，实施成本低，能一次性消除网络与跨域问题。

---

## 6. 落地实施方案（可直接执行）

**目标**：统一服务端口为 `33333`，由 FastAPI 同时托管静态资源与 API；前端全部改为“相对路径”访问 API。

1) **后端改动**（`services/server/app.py`）

* __只保留一条静态挂载__：
  - 放在所有 API 路由之后：
    ```python
    app.mount("/", StaticFiles(directory=str(Path(__file__).resolve().parents[2] / "web"), html=True), name="static")
    ```

* __可选：将 `@app.get("/")` JSON root 调整到 `/meta`__：
  - 避免与静态 root 冲突：
    ```python
    @app.get("/meta")
    async def meta():
        return {...}
    ```

2) **前端改动**（`web/notes/index-standalone.html`）

* __相对路径策略__：将所有 `fetch(`${apiBase}/xxx`)` 改为 `fetch('/xxx')`；移除 `apiBase` 的硬编码，避免端口漂移导致的不一致。
  - 例如：
    ```js
    // before: fetch(`${apiBase}/preprocess`, {...})
    // after:
    fetch('/preprocess', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) })
    ```

* __健康检查__：`fetch('/healthz')`（相对路径）。

3) **启动命令**

```bash
pkill -f 'uvicorn' || true
python3 -m uvicorn services.server.app:app --host 127.0.0.1 --port 33333
```

4) **访问入口**

* 统一访问地址：`http://127.0.0.1:33333/`（会直接提供 `web/` 下的页面，根目录会命中 `web/index.html`，跳转到 `notes/index-standalone.html`）。

5) **端到端验收清单**

* __健康检查__：日志框出现 `[api] 健康检查：可用`。
* __提交链路__：
  - 选择议题 → 选择 Agent → 输入 → Alt+Enter。
  - 日志框出现 `[preprocess] start via API` → `done`。
  - 中栏出现“被加工后的文本”。

* __失败排查__：
  - `logs/queue/preprocess_external.last_err.txt` 查看 stderr 摘要。
  - 前端日志框会显示细化后的错误消息（`err.message`）。

---

## 7. 需要你确认的事项

* 是否同意采用“统一服务模式（端口 `33333`、相对路径策略）”？
* 是否同意我一次性执行第6节的所有改动（后端、前端、启动）并完成验收？

> 你的确认后，我将直接执行，不再打扰你逐步操作。

--- 

我保证这将是最后一次大规模的代码修改。我会在执行前再次确认方案的完整性，并一次性完成。
